[[child_processes]]
== Child processes

There are several ways of creating child processes in babashka. Let's start with
the easiest one.

=== clojure.java.shell

A common way to shell out to another process is via `clojure.java.shell`:

[source,clojure]
----
user=> (require '[clojure.java.shell :refer [sh]])
nil
user=> (sh "ls")
{:exit 0, :out "README.md\ndist\ngh-pages\nscript\nsrc\n", :err ""}
----

As you can see the result of `:out` are the lines of text produced by `ls`. The
`:exit` code was `0` and there was no output on stderr.

[source,clojure]
----
user=> (sh "ls" "foo")
{:exit 1, :out "", :err "ls: foo: No such file or directory\n"}
----

If we invoke `ls` with a non-existing file, there is error output, but not
output on stdout and the `:exit` code is `1`.

For more information on `clojure.java.shell`, read the
https://clojure.github.io/clojure/clojure.java.shell-api.html[API documentation]

=== java.lang.Process

What if we wanted to start a test runner that watches a source directory and
executes tests whenever a file changes? Using `clojure.java.shell/sh` for this
has a few drawbacks:

- We have no control over stopping the watcher process
- We can't see any output from the test runner until the process finishes

Using `java.lang.ProcessBuilder` and `java.lang.Process` gives us the extra
power we need to overcome these limitations.

.test_runner_watch.clj
[source,clojure]
----
#!/usr/bin/env bb

(import java.lang.ProcessBuilder$Redirect)

(defn test-runner-watch []
  (let [cmd ["clojure" "-A:kaocha" "-m" "kaocha.runner" "--watch"] <1>
        pb (doto (ProcessBuilder. cmd) <2>
             (.redirectOutput ProcessBuilder$Redirect/INHERIT)) <3>
        proc (.start pb)] <4>
    (-> (Runtime/getRuntime)
        (.addShutdownHook (Thread. #(.destroy proc)))) <5>
    proc))

(.waitFor (test-runner-watch)) <6>
----

<1> The command and its arguments

<2> Construction of a `Process` is done using `ProcessBuilder`

<3> This sends the output of the child process directly to the parent process's
standard out.

<4> Calling `start` on a `ProcessBuilder` instance starts the process and gives
us a `Process` instance.

<5> This line will destroy the child process before the parent process exits.

<6> `waitFor` waits until the child process ends and returns its exit code. If
we would not include this, our script would end without waiting for the watcher.

When calling the script, we can see output from the test runner while it is running:

[source,shell]
----
$ test_runner_watch.clj
[(.................)(..)]
7 tests, 19 assertions, 0 failures.
----

// TODO https://github.com/borkdude/babashka/issues/299 infinite stream
// TODO https://github.com/borkdude/babashka/issues/299 reading input
